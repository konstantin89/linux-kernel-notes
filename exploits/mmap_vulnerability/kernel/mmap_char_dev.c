
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/mm.h>
#include <linux/string.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kosta");
MODULE_DESCRIPTION("mmap exploit device");

#define DEVICE_NAME "mmap_char_dev"
#define BUF_SIZE 4096

typedef struct MappedData
{
    int i;
    char str[16];
    unsigned char binData[256];
} MappedData;

static struct cdev cdev;
struct device *device_mmap;
struct class *class_mmap_dev;

static char *buffer;
static dev_t device_number;

static int mmap_char_open(struct inode *inode, struct file *file) 
{
    MappedData * dataPtr = NULL;

    printk(KERN_INFO "Char device open called\n");

    if (NULL == buffer)
    {
        return 0;
    }

    dataPtr = (MappedData*)buffer;
    dataPtr->i = 20;
    strcpy(dataPtr->str, "text");
    memset(dataPtr->binData, 0, sizeof(dataPtr->binData));

    return 0;
}

static int mmap_char_release(struct inode *inode, struct file *file) 
{
    return 0;
}

static int mmap_char_mmap(struct file *file, struct vm_area_struct *vma) 
{
    int ret;
    unsigned long size = vma->vm_end - vma->vm_start;

    // Disabling size check to enable a vulnerability.
    //if (size > BUF_SIZE)
    //    return -EINVAL;

    phys_addr_t mappedPhysAddr = virt_to_phys(buffer) >> PAGE_SHIFT;

    // Remap to userspace
    ret = remap_pfn_range(vma, vma->vm_start, mappedPhysAddr, 
                          size, vma->vm_page_prot);
    if (ret < 0)
    {
        printk(KERN_ERR "remap_pfn_range failed\n");
        return ret;
    }

    printk(KERN_INFO "Device memory size [%d] bytes, mapped [%lu] bytes\n",
           BUF_SIZE, size);

    printk(KERN_INFO "Mapped virtual addr [0x%p] , mapped phys addr [%x] \n",
           buffer, mappedPhysAddr);

    return 0;
}

static struct file_operations mmap_char_fops = 
{
    .owner = THIS_MODULE,
    .open = mmap_char_open,
    .release = mmap_char_release,
    .mmap = mmap_char_mmap,
};

static int __init mmap_char_init(void) 
{
    int ret;

    // Allocate buffer
    buffer = kmalloc(BUF_SIZE, GFP_KERNEL);
    if (!buffer) 
    {
        printk(KERN_ERR "Failed to allocate buffer\n");
        return -ENOMEM;
    }

    // Register character device
    ret = alloc_chrdev_region(&device_number, 0, 1, DEVICE_NAME);
    if (ret < 0) 
    {
        printk(KERN_ERR "Failed to allocate character device\n");
        goto out;
    }

    cdev_init(&cdev, &mmap_char_fops);
    cdev.owner = THIS_MODULE;

    ret = cdev_add(&cdev, device_number, 1);
    if (ret < 0) 
    {
        printk(KERN_ERR "Failed to add character device\n");
        goto unreg_chrdev;
    }

    class_mmap_dev = class_create(THIS_MODULE, "mmap_char_class");
    if(IS_ERR(class_mmap_dev))
    {
        pr_err("Class creation failed\n");
        ret = PTR_ERR(class_mmap_dev);
        goto cdev_del;
    }

    device_mmap = device_create(class_mmap_dev,NULL, device_number, NULL, DEVICE_NAME);
    if(IS_ERR(device_mmap))
    {
        pr_err("Device create failed\n");
        ret = PTR_ERR(device_mmap);
        goto class_del;
    }

    printk(KERN_INFO "MMap character device loaded\n");
    return 0;

class_del:
	class_destroy(class_mmap_dev);
cdev_del:
	cdev_del(&cdev);	
unreg_chrdev:
	unregister_chrdev_region(device_number,1);
out:
	pr_info("Module insertion failed\n");
	return ret;
}

static void __exit mmap_char_exit(void) 
{
	device_destroy(class_mmap_dev, device_number);
    class_destroy(class_mmap_dev);
    cdev_del(&cdev);
    unregister_chrdev_region(device_number, 1);

    kfree(buffer);
    printk(KERN_INFO "MMap character device unloaded\n");
}

module_init(mmap_char_init);
module_exit(mmap_char_exit);
